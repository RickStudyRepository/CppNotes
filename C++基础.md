# C++基础

## C++关键字

### C++关键字列表

#### C++98标准

##### [数据类型关键字](https://en.cppreference.com/w/cpp/language/types)

| 关键字    | 含义                          | 关键字   | 含义                 |
| --------- | ----------------------------- | -------- | -------------------- |
| `bool`    | 布尔型变量类型                | `float`  | 单精度浮点型变量类型 |
| `char`    | 字符型变量类型                | `double` | 双精度浮点型变量类型 |
| `wchar_t` | 宽字符型变量类型，支持Unicode | `enum`   | 枚举类型             |
| `short`   | 短整型变量类型                | `struct` | 结构体类型           |
| `int`     | 整型变量类型                  | `union`  | 共用体类型           |
| `long`    | 长整型变量类型                | `class`  | 类类型               |
| `void`    | 空类型                        |          |                      |

##### `bool`变量常量值关键字

| 关键字 | 含义    | 关键字  | 含义    |
| ------ | ------- | ------- | ------- |
| `true` | 真，`1` | `false` | 假，`0` |

##### 修饰性关键字

| 关键字    | 含义                                                         | 关键字     | 含义                                                         |
| --------- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |
| `signed`  | 将被修饰的变量类型定义为有符号类型的变量（默认值，通常省略） | `unsigned` | 将被修饰的变量类型定义为无符号类型的变量                     |
| `const`   | `constant`，不可变的含义                                     | `volatile` | 被修饰的变量是易变的（外部因素可能会引起变量值的变化），编译器每次都会从内存中取出该变量的值，而不会尝试从寄存器中读取，详见[CppReference](https://en.cppreference.com/w/cpp/language/cv)，[菜鸟教程](https://www.runoob.com/w3cnote/c-volatile-keyword.html) |
| `mutable` | 被该关键字修饰的变量如果位于某个`const`**组合类型**变量中，对该变量的修改是合法的 | `register` | 将被修饰的变量直接存储到寄存器中，加快读写速度               |
| `static`  | 修饰静态变量或函数，不同语境下，含义有所不同                 | `inline`   | 修饰函数，将所修饰的函数定义为内联函数，减少调用函数的开销，必需放在**函数定义**前，放到函数声明前没有效果 |
| `extern`  | 1. 可被别的模块访问<br>2. 引入使用别的语言编写的代码         |            |                                                              |

##### 类相关关键字

| 关键字      | 含义                                                         | 关键字                  | 含义                                       |
| ----------- | ------------------------------------------------------------ | ----------------------- | ------------------------------------------ |
| `private`   | 私有数据                                                     | [`explicit`](#explicit) | 将被修饰的构造函数限制为只能被**显式调用** |
| `public`    | 公有数据                                                     | `virtual`               | 将被修饰的成员函数定义为虚函数             |
| `protected` | 受保护的数据，直接子类可见                                   | `this`                  | 在类的定义中指向被实例化的对象本身的指针   |
| `friend`    | 1. 使得被修饰的方法或类可以访问类的私有数据和受保护的数据<br>2. 友元不是当前类的成员 |                         |                                            |

##### 分支循环相关关键字

| 关键字    | 含义                            | 关键字     | 含义                               |
| --------- | ------------------------------- | ---------- | ---------------------------------- |
| `if`      | `if`条件语句                    | `else`     | 与`if`配对使用                     |
| `switch`  | 开关语句                        | `case`     | 开关语句的一种情况                 |
| `default` | 开关语句的默认情况              | `while`    | `while`循环                        |
| `do`      | 与`while`配合形成`do-while`循环 | `for`      | `for`循环                          |
| `break`   | 结束循环或结束开关语句          | `continue` | 结束某一轮循环                     |
| `goto`    | 无条件跳转到指定标号的代码块    | `return`   | 结束一个函数的执行，并返回主调函数 |

##### 动态内存分配相关关键字

| 关键字 | 含义                                                     | 关键字   | 含义                                                  |
| ------ | -------------------------------------------------------- | -------- | ----------------------------------------------------- |
| `new`  | 申请一块指定数据类型大小的动态内存，会调用相应的构造函数 | `delete` | 释放由`new`运算符申请的动态内存，会调用相应的析构函数 |

##### 异常处理相关关键字

| 关键字  | 含义             | 关键字  | 含义           |
| ------- | ---------------- | ------- | -------------- |
| `try`   | 尝试执行的代码块 | `catch` | 捕获指定的异常 |
| `throw` | 抛出异常         |         |                |

##### 类型转换相关关键字

| 关键字             | 含义                                                         |
| ------------------ | ------------------------------------------------------------ |
| `const_cast`       | 去除`const`或`volatile`修饰，但是会带来`undefined behavior`，详见[CppReference](https://en.cppreference.com/w/cpp/language/const_cast)，不能用于函数指针(包括成员函数指针) |
| `static_cast`      | 进行各种数据类型之间的转换，不能代替`const_cast`,详见[CppReference](https://en.cppreference.com/w/cpp/language/static_cast) |
| `dynamic_cast`     | 用于类与类之间的**安全**转换，这些类具有**父子或兄弟关系**，转型失败将返回`null pointer`或抛出`std::bad_cast`异常，不能代替`const_cast` |
| `reinterpret_cast` | 功能最为强大，可以在不同的数据类型之间任意转换，但是也**最不安全**，不推荐使用，不能代替`const_cast`，详见[CppReference](https://en.cppreference.com/w/cpp/language/reinterpret_cast) |

##### 命名空间相关关键字

| 关键字      | 含义             | 关键字  | 含义                     |
| ----------- | ---------------- | ------- | ------------------------ |
| `namespace` | 定义一个命名空间 | `using` | 引入命名空间中的所有成员 |

##### 类型相关关键字

| 关键字     | 含义                                     | 关键字    | 含义                       |
| ---------- | ---------------------------------------- | --------- | -------------------------- |
| `template` | 用于声明模板方法或模板类                 | `typedef` | 给一个数据类型定义一个别名 |
| `typename` | 指明一个`token`是一个类型名              | `typeid`  |                            |
| `sizeof`   | 计算指定数据类型的一个变量占用的空间大小 |           |                            |

##### 其他关键字

| 关键字     | 含义             | 关键字   | 含义 |
| ---------- | ---------------- | -------- | ---- |
| `asm`      | 嵌入一段汇编代码 | `auto`   |      |
| `operator` |                  | `export` |      |

### `explicit`

- 作用到**类的构造函数**上
- 表示类的构造函数只能被**显示调用**
- 只用于修饰**单参**构造函数
- 避免构造函数的隐式调用

```c++
#include <iostream>

using namespace std;

class B {
private:
    double c;
    float b;
    int a;
public:
    B(int a) {
        this->a = a;
        b = 1.0f;
        c = 1.0;
    }
	// 只能显式调用的单参构造函数
    explicit B(float b) {
        a = 1;
        this->b = b;
        c = 1.0;
    }
	// 只能显示调用的单参构造函数
    explicit B(double c) {
        a = 1;
        b = 1.0f;
        this->c = c;
    }

    void print() {
        cout << "a: " << a << ", b: " << b << ", c: " << c << endl;
    }
};

void doSomething(B b) {
    b.print();
}

int main() {
    // 正确，产生显式类型转换，但是我更愿意理解为调用了相应的构造函数，构造的对象被放到了这里
    // 但是转念一想，构造函数没有返回值，似乎不能这样理解
    doSomething(B(28));
    // 正确，将会产生隐式类型转换，理由是，参数是整数的构造函数没有explicit声明
    doSomething(25);
    // 正确，将会产生显式类型转换
    doSomething(B(12.34f));
    // 正确，先进行第一次隐式类型转换，将参数转为int类型，然后再产生隐式类型转换，理由是参数为float的构造函数被声明为了explicit
    // 然而如果没有参数为int并且没有被声明为explicit的构造函数，就会产生如下的编译错误
    // could not convert '3.41199989e+1f' from 'float' to 'B'
    doSomething(34.12f);
    // 正确，先进行第一次隐式类型转换，将参数转为int类型，然后再产生隐式类型转换，理由是参数为float的构造函数被声明为了explicit
    // 然而如果没有参数为int并且没有被声明为explicit的构造函数，就会产生如下的编译错误
    // could not convert '1.2345000000000001e+1' from 'double' to 'B'
    doSomething(12.345);
    return 0;
}

```

## C++输入输出

[控制`bool`变量的输出格式](https://en.cppreference.com/w/cpp/language/bool_literal)

